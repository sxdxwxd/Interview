# 深圳某中厂笔试题目 -- Java后端岗

## 逻辑题目1：字符串分割组合

实现以下2个接口

**本题不能使用语言的基本分割组合函数(如Java或python的split)，需要自己写分割过程**

1) 字符串拆分成数组，如”ab&&2”通过”&&”做分隔符，分割得到字符串数组[“ab”,”2”] 
2) 实现字符串组合，如[“ab”,”2”]通过”&&”分隔符，组合成字符串”ab&&2”

```Java
//接口定义
public interface StringSplitter {
    String[] split(String input, String delimiter);
}

public interface StringCombiner {
    String combine(String[] parts, String delimiter);
}

//具体实现类
public class StringProcessor implements StringSplitter, StringCombiner {

    @Override
    public String[] split(String input, String delimiter) {
        // 处理空值边界
        if (input == null || input.isEmpty()) return new String[0];
        if (delimiter == null || delimiter.isEmpty()) return new String[]{input};

        int startIndex = 0; // 当前子串起始位置
        java.util.List<String> segments = new java.util.ArrayList<>();
        int delimiterIndex; // 分隔符位置

        // 核心分割逻辑：循环定位分隔符并截取子串
        while ((delimiterIndex = input.indexOf(delimiter, startIndex)) != -1) {
            // 截取分隔符前的子串（左闭右开区间）
            segments.add(input.substring(startIndex, delimiterIndex));
            startIndex = delimiterIndex + delimiter.length(); // 跳过分隔符
        }
        // 添加末尾剩余子串
        segments.add(input.substring(startIndex));
        return segments.toArray(new String[0]);
    }

    @Override
    public String combine(String[] parts, String delimiter) {
        if (parts == null || parts.length == 0) return "";
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            result.append(parts[i]);
            // 非末尾元素添加分隔符
            if (i < parts.length - 1) result.append(delimiter);
        }
        return result.toString();
    }
}
```

## 逻辑题目2：找相同的数

题目：1000个整数，数值的范围是[0,999]，有且只有2个相同的数，请编写程序找出来

```java
//方法一：数学逻辑法

public﻿ int findDuplicateNumber(int[] numbers) {
    int expectedSum = 999  * (999 + 1) / 2
    int actualSum = 0;
    for (int num : numbers) {
        actualSum += num;
    }
    return actualSum - expectedSum;
}


//方法二：哈希表法

public int findByHashMap(int[] numbers) {
    Map<Integer, Integer> countMap = new HashMap<>();
    for (int num : numbers) {
        if (countMap.containsKey(num)) {
            return num; 
        }
        countMap.put(num, 1);
    }
    return -1;
}


//方法三：位运算法

public static int findByXOR(int[] numbers) {
    int result = 0;
    for (int num : numbers) result ^= num;
    for (int i = 0; i < 1000; i++) result ^= i;
    return result;
}
```

## 逻辑题目3：求字母组合

有26个字母a-z，找出所有字母的组合，a、b、c、ab、abc、ac、a~z都是一个组合(顺序无关)

```Java
public static List<String> getAllCombinations() {
    char[] alphabet = new char[26];
    for (int i = 0; i < 26; i++) {
        alphabet[i] = (char) ('a' + i);
    }

    List<String> result = new ArrayList<>();
    for (int i = 1; i <= 26; i++) {
        getCombinations(alphabet, "", i, result);
    }

    return result;
}

private static void getCombinations(char[] alphabet, String prefix, int k, List<String> result) {
    if (k == 0) {
        result.add(prefix);
        return;
    }

    for (int i = 0; i < 26; i++) {
        if (prefix.length() == 0 || alphabet[i] > prefix.charAt(prefix.length() - 1)) {
            getCombinations(alphabet, prefix + alphabet[i], k - 1, result);
        }
    }
}

```

## 题目4：多线程编程

写两个线程，两个线程轮流打印数字，从0一直打印到200

```Java
//方法一：使用 volatile 关键字

import java.util.concurrent.atomic.AtomicInteger;

//两个线程轮流输出0-200
public class MultiThread1 {
    static AtomicInteger integer = new AtomicInteger(0);
    static volatile boolean flag = true;
    public static void main(String[] args) {

        new Thread(() -> {
            while(integer.get()<=200){
                if(flag){
                    System.out.println(Thread.currentThread().getName()+"打印出"+integer.getAndIncrement());
                    flag = false;
                }

            }
        }).start();
        new Thread(() -> {
            while(integer.get()<=200){
                if(!flag){
                    System.out.println(Thread.currentThread().getName()+"打印出"+integer.getAndIncrement());
                    flag = true;
                }

            }
        }).start();
    }
}




//方法二：加锁阻塞线程，使用 Sychronized 的 wait、notify

import java.util.concurrent.atomic.AtomicInteger;

//两个线程轮流输出0-200
public class MultiThread2 {
    static AtomicInteger integer = new AtomicInteger(0);
    static Object lock = new Object();
    public static void main(String[] args) {

        new Thread(() -> {
            while(integer.get()<=200){
                synchronized(lock){
                    lock.notify();
                    System.out.println(Thread.currentThread().getName()+"打印出"+integer.getAndIncrement());
                    try{
                        lock.wait();
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
            }
        }).start();
        new Thread(() -> {
            while(integer.get()<=200){
                synchronized(lock){
                    lock.notify();
                    System.out.println(Thread.currentThread().getName()+"打印出"+integer.getAndIncrement());
                    try{
                        lock.wait();
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}

```

## 题目5：Java-sql 考察

题目：有一张数据库表其表结构为：

```sql
create table student(
	id int,
	name varchar(32),
	age int,
	score double(4,1),
	birthday date,
	sex int,
	insert_time timestamp
);
```

请按照年龄(age)分组，查出不同组的平均分和人数，分数(score)低于60分的人不参与分组，某一年龄分组人数小于2，该年龄段不参与分组，请按照以上要求写出sql语句

```sql
SELECT age,
       AVG(score) AS avg_score,
       COUNT(*) AS count
FROM student
WHERE score >= 60
GROUP BY age
HAVING COUNT(*) >= 2;
```
